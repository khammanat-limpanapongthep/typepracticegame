<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Type Monkey ‚Äî Canvas</title>

<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#0b0f14; --panel:#111823; --ink:#e8f0ff; --muted:#9bb0c9;
    --accent:#5ee397; --accent-2:#ffd166; --bad:#ff6b6b; --good:#7cffc4;
    --yellow:#e2b714;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:radial-gradient(80vmax 80vmax at 80% -10%, #1a2433 0%, #0b0f14 55%);
    color:var(--ink); font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Cantarell,Noto Sans,Arial;
    display:grid; place-items:center; padding:18px;
  }
  .app{
    width:min(980px,96vw);
    background:linear-gradient(180deg,#101621,#0d1420);
    border:1px solid #1d2a3b; border-radius:16px;
    box-shadow:0 10px 30px rgba(0,0,0,.55), inset 0 1px 0 rgba(255,255,255,.03);
    padding:16px; position:relative;
  }
  .row{display:flex; align-items:center; gap:12px; flex-wrap:wrap; justify-content:space-between}
  .title{font-weight:800}
  .badge{font-size:12px; color:var(--muted); background:#0b131f; border:1px solid #1b2a3e; border-radius:999px; padding:6px 10px}
  .hud{display:flex; gap:10px; flex-wrap:wrap}
  .stat{background:#0b131f; border:1px solid #1b2a3e; padding:8px 10px; border-radius:10px; min-width:88px; text-align:center}
  .stat .l{font-size:11px; color:var(--muted); text-transform:uppercase; letter-spacing:.6px}
  .stat .v{font-size:18px; font-weight:700; margin-top:2px}
  .controls{display:flex; gap:8px; margin-top:10px; flex-wrap:wrap}
  /* base buttons (top controls) */
  button{background:#0b131f; border:1px solid #1b2a3e; color:var(--ink); padding:8px 12px; border-radius:10px; cursor:pointer}
  button:hover{box-shadow:0 0 0 2px #1b2a3e inset}
  .hint{margin-top:8px; color:var(--muted); font-size:12px}
  canvas.stage{display:block; width:100%; height:420px; border-radius:12px; background:#0d1623; border:1px solid #1c2a3f}
  #sink{position:absolute; left:-9999px; top:-9999px; opacity:0; width:0; height:0; caret-color:transparent}

  /* custom text modal */
  .overlay{position:absolute; inset:0; display:none; align-items:center; justify-content:center;
    background:rgba(0,0,0,.5); backdrop-filter:saturate(120%) blur(2px); padding:20px; z-index:10;}
  .overlay.show{display:flex;}
  .sheet{width:min(880px,95vw); background:#0d1623; border:1px solid #1c2a3f; border-radius:12px; padding:16px;
    box-shadow:0 10px 30px rgba(0,0,0,.6);}
  .sheet h3{margin:0 0 8px 0; font-size:16px}
  .sheet textarea{width:100%; height:220px; resize:vertical; background:#0b131f; color:#e8f0ff;
    border:1px solid #1b2a3e; border-radius:10px; padding:10px; font-size:14px; line-height:1.5;
    font-family:'JetBrains Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace;}
  .sheet .actions{display:flex; gap:8px; margin-top:10px; justify-content:flex-end}

  /* RESULTS PAGE */
  .results{display:none; margin-top:12px;}
  .results.show{display:block;}
  .result-grid{display:grid; grid-template-columns: 240px 1fr; gap:18px; align-items:start}
  .big{font-size:56px; font-weight:800; color:var(--yellow); line-height:1}
  .label{color:var(--muted); text-transform:uppercase; letter-spacing:.6px; font-size:12px; margin-top:6px}
  .kvs{display:flex; gap:18px; flex-wrap:wrap; margin-top:8px}
  .kv{min-width:120px}
  .kv .k{color:var(--muted); font-size:12px; text-transform:uppercase; letter-spacing:.6px}
  .kv .v{font-weight:700; font-size:18px; margin-top:2px}
  .chart{width:100%; height:240px; border:1px solid #1b2a3e; border-radius:10px; background:#0b131f}

  /* centered, flat results buttons (same color as panel, no shade) */
  .res-actions{
    grid-column:1 / -1;    /* span both grid columns */
    display:flex;
    justify-content:center;
    align-items:center;
    gap:14px;
    flex-wrap:nowrap;      /* keep in one row */
    width:100%;
    margin-top:6px;
  }
  .res-actions button{
    appearance:none;
    background:var(--panel); /* matches container */
    color:var(--ink);
    padding:10px 16px;
    border-radius:12px;
    border:1px solid #1b2a3e;
    box-shadow:none;         /* no shadow */
    font-weight:600;
    letter-spacing:.2px;
    cursor:pointer;
    transition:border-color .15s ease, transform .12s ease;
    flex:0 0 auto;
  }
  .res-actions button:hover{border-color:#2a3d58; transform:translateY(-1px)}
  .res-actions button:active{transform:none}
  .res-actions button:focus-visible{outline:none; border-color:var(--yellow)}
</style>
</head>
<body>
  <div class="app" id="app">
    <div class="row">
      <div style="display:flex; align-items:center; gap:10px">
        <div class="title">üß†üêí Type Monkey ‚Äî Canvas</div>
        <span class="badge">words: <b id="wordCount">50</b></span>
        <span class="badge">timer: <b id="timerBadge">30s</b></span>
      </div>
      <div class="hud" id="hud">
        <div class="stat"><div class="l">wpm</div><div class="v" id="wpm">0</div></div>
        <div class="stat"><div class="l">accuracy</div><div class="v" id="acc">100%</div></div>
        <div class="stat"><div class="l">time</div><div class="v" id="time">30.0</div></div>
      </div>
    </div>

    <!-- TYPING VIEW -->
    <canvas id="stage" class="stage" width="1600" height="700" aria-label="typing area"></canvas>
    <div class="controls" id="controls">
      <button id="restart">repeat (Esc / Ctrl+R)</button>
      <button id="newText">next test (Ctrl+N)</button>
      <button id="shorter">shorter</button>
      <button id="longer">longer</button>
      <button id="custom">use my text</button>
    </div>
    <div class="hint" id="hint">
      Start typing to begin. Backspace fixes mistakes. If you switch tabs, press any key or click the canvas to refocus.
    </div>

    <!-- CUSTOM TEXT OVERLAY -->
    <div class="overlay" id="overlay">
      <div class="sheet">
        <h3>Paste your own paragraph</h3>
        <textarea id="customArea" placeholder="Paste or type your text here..."></textarea>
        <div class="actions">
          <button id="cancelCustom">cancel</button>
          <button id="useCustom">use this text</button>
        </div>
      </div>
    </div>

    <!-- RESULTS PAGE -->
    <div class="results" id="results">
      <div class="result-grid">
        <div class="summary">
          <div class="label">wpm</div>
          <div class="big" id="resWpm">0</div>
          <div class="label" style="margin-top:14px">acc</div>
          <div class="big" id="resAcc">0%</div>

          <div class="kvs">
            <div class="kv"><div class="k">test type</div><div class="v" id="resType">time 30 ‚Ä¢ english</div></div>
            <div class="kv"><div class="k">raw</div><div class="v" id="resRaw">0</div></div>
            <div class="kv"><div class="k">characters</div><div class="v" id="resChars">0/0/0/0</div></div>
            <div class="kv"><div class="k">consistency</div><div class="v" id="resCons">‚Äî</div></div>
            <div class="kv"><div class="k">time</div><div class="v" id="resTime">30s</div></div>
            <div class="kv"><div class="k">other</div><div class="v" id="resOther">‚Äî</div></div>
          </div>
        </div>

        <div>
          <canvas id="resChart" class="chart" width="620" height="240"></canvas>
          <div class="label" style="margin-top:8px">Words per Minute</div>
        </div>

        <!-- full-width row so we can center the buttons -->
        <div class="res-actions">
          <button id="btnRepeat">repeat test</button>
          <button id="btnNext">next test</button>
          <button id="btnOwn">use my text</button>
        </div>
      </div>
    </div>
  </div>

  <input id="sink" autocomplete="off" autocapitalize="off" spellcheck="false" />

<script>
(() => {
  // ---------- metrics ----------
  const FONT_FAMILY = "'JetBrains Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace";
  const FONT_SIZE = 28;
  const LETTER_SPACING = 1;
  const LINE_HEIGHT_FACTOR = 1.7;

  const CARET_COLOR = "#e2b714";
  const CARET_THICKNESS = 2;
  const CARET_TOP = 0.15;
  const CARET_HEIGHT = 0.78;

  // ---------- config ----------
  const TIMER_LEN = 30; // default 30s
  const WORD_GOAL_DEFAULT = 50;

  const COLORS = {
    bg: "#0d1623",
    ink: "#9bb0c9",
    correct: "#7cffc4",
    wrong: "#ff6b6b",
    caret: CARET_COLOR
  };

  const SAMPLES = [
    "monkeys type better when coffee is near and bugs run away",
    "practice every day and tiny gains stack into big jumps",
    "focus on accuracy then the speed will arrive on its own",
    "clean code reads like prose and bends without breaking",
    "java and python both shine when tested with care",
    "consistency beats intensity so show up for ten minutes",
    "measure what matters wpm accuracy and calm breathing",
    "small hands big brain type monkey never skips warmup",
    "arrays lists maps sets know your tools and use them well",
    "latency hides in loops profile before you optimize"
  ];

  // ---------- elements ----------
  const app = document.getElementById('app');
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d');
  const resultsView = document.getElementById('results');
  const typingEls = [canvas, document.getElementById('controls'), document.getElementById('hud'), document.getElementById('hint')];
  const els = {
    wpm: document.getElementById('wpm'),
    acc: document.getElementById('acc'),
    time: document.getElementById('time'),
    wordCount: document.getElementById('wordCount'),
    timerBadge: document.getElementById('timerBadge'),
    restart: document.getElementById('restart'),
    newText: document.getElementById('newText'),
    shorter: document.getElementById('shorter'),
    longer: document.getElementById('longer'),
    custom: document.getElementById('custom'),
    overlay: document.getElementById('overlay'),
    customArea: document.getElementById('customArea'),
    cancelCustom: document.getElementById('cancelCustom'),
    useCustom: document.getElementById('useCustom'),
    // results
    resWpm: document.getElementById('resWpm'),
    resAcc: document.getElementById('resAcc'),
    resType: document.getElementById('resType'),
    resRaw: document.getElementById('resRaw'),
    resChars: document.getElementById('resChars'),
    resCons: document.getElementById('resCons'),
    resTime: document.getElementById('resTime'),
    resOther: document.getElementById('resOther'),
    resChart: document.getElementById('resChart'),
    btnRepeat: document.getElementById('btnRepeat'),
    btnNext: document.getElementById('btnNext'),
    btnOwn: document.getElementById('btnOwn'),
    sink: document.getElementById('sink')
  };

  // ---------- state ----------
  const params = new URLSearchParams(location.search);
  let wordsTarget = clamp(parseInt(params.get('w')) || WORD_GOAL_DEFAULT, 5, 200);
  let timerSeconds = clamp(parseInt(params.get('t')) || TIMER_LEN, 15, 300);

  let state = {
    text: "",
    chars: [],
    marks: [],      // 0=pending, 1=correct, -1=wrong
    index: 0,
    started: false,
    startTimeMs: 0,       // first keystroke time
    remaining: timerSeconds,
    timerId: null,
    // layout
    dpr: 1, cols: 0, rows: 0, charW: 0, lineH: 0, viewRow: 0, pos: [],
    // series for graph and consistency
    samples: [], sampleSeconds: [], lastSampleSec: 0,
    lastTypeAt: 0, afkSeconds: 0
  };

  // ---------- helpers ----------
  function clamp(n,a,b){return Math.max(a,Math.min(b,n));}
  function normalizeText(s){ return (s || "").replace(/\s+/g,' ').trim().replace(/\s{2,}/g,' '); }
  function pickText(wordGoal){
    const words = [];
    while(words.length < wordGoal){
      const w = SAMPLES[Math.floor(Math.random()*SAMPLES.length)].split(/\s+/);
      words.push(...w);
    }
    return words.slice(0, wordGoal).join(' ');
  }
  function setFont(){ ctx.font = `${FONT_SIZE * state.dpr}px ${FONT_FAMILY}`; ctx.textBaseline = "top"; }
  function measure(){
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    state.dpr = dpr;
    const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
    canvas.width  = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    setFont();
    state.charW = Math.round(ctx.measureText("0").width) + Math.round(LETTER_SPACING * dpr);
    state.lineH = Math.round(FONT_SIZE * LINE_HEIGHT_FACTOR * dpr);
    const innerW = canvas.width  - 48 * dpr, innerH = canvas.height - 48 * dpr;
    state.cols = Math.max(8, Math.floor(innerW / state.charW));
    state.rows = Math.max(1, Math.floor(innerH / state.lineH));
  }
  function buildLayout(){
    state.pos = new Array(state.chars.length);
    let row = 0, col = 0, i = 0;
    while (i < state.chars.length) {
      if (state.chars[i] === ' ') { if (col >= state.cols){ row++; col = 0; } state.pos[i] = {row, col}; col++; i++; continue; }
      let j = i; while (j < state.chars.length && state.chars[j] !== ' ') j++;
      const len = j - i;
      if (col > 0 && col + len > state.cols){ row++; col = 0; }
      for (let k=i;k<j;k++){ state.pos[k] = {row, col}; col++; }
      if (j < state.chars.length && state.chars[j] === ' '){ if (col >= state.cols){ row++; col = 0; } state.pos[j] = {row, col}; col++; i = j+1; }
      else { i = j; }
    }
  }
  function ensureCaretVisible(){
    const rc = state.pos[state.index] || {row:0,col:0};
    const row = rc.row, bottom = state.viewRow + state.rows - 1;
    if (row > bottom) state.viewRow = row - (state.rows - 1);
    if (row < state.viewRow) state.viewRow = row;
    state.viewRow = Math.max(0, state.viewRow);
  }

  // ---------- rendering ----------
  function clear(){ ctx.fillStyle = COLORS.bg; ctx.fillRect(0,0,canvas.width,canvas.height); }
  function drawText(){
    const dpr = state.dpr, pad = 24 * dpr, startX = pad, startY = pad;
    for (let i = 0; i < state.chars.length; i++) {
      const rc = state.pos[i]; if (!rc) continue;
      const vRow = rc.row - state.viewRow; if (vRow < 0 || vRow >= state.rows) continue;
      const x = startX + rc.col * state.charW, y = startY + vRow * state.lineH;
      const ch = state.chars[i], mark = state.marks[i] || 0;
      if (mark === 1) ctx.fillStyle = COLORS.correct;
      else if (mark === -1) ctx.fillStyle = COLORS.wrong;
      else ctx.fillStyle = COLORS.ink;
      ctx.fillText(ch, x, y);
    }
    // caret
    if (Math.floor(Date.now()/500) % 2 === 0) {
      const rc = state.pos[state.index];
      if (rc){
        const vRow = rc.row - state.viewRow; if (vRow>=0 && vRow<state.rows){
          const dpr = state.dpr, pad = 24*dpr, x = pad + rc.col * state.charW, y = pad + vRow*state.lineH;
          ctx.fillStyle = CARET_COLOR;
          const top = Math.round(FONT_SIZE * dpr * CARET_TOP), h = Math.round(FONT_SIZE * dpr * CARET_HEIGHT);
          ctx.fillRect(x, y + top, Math.max(1, Math.round(CARET_THICKNESS * dpr)), h);
        }
      }
    }
  }
  function render(){ clear(); drawText(); requestAnimationFrame(render); }

  // ---------- stats ----------
  function elapsedMinutes(){
    if (!state.started) return 0;
    const ms = Math.max(1, performance.now() - state.startTimeMs);
    return ms / 60000;
  }
  function recomputeStats(){
    let correct=0, wrong=0;
    for (const m of state.marks){ if (m===1) correct++; else if (m===-1) wrong++; }
    const typed = correct + wrong;
    const tmin = elapsedMinutes();
    const wpm = tmin>0 ? (correct/5) / tmin : 0;        // correct-only WPM
    const raw = tmin>0 ? (typed/5) / tmin : 0;          // gross WPM
    const acc = typed>0 ? (correct/typed)*100 : 100;
    els.wpm.textContent = Math.round(wpm);
    els.acc.textContent = `${Math.round(acc)}%`;
    return {correct, wrong, typed, wpm, raw, acc: Math.round(acc)};
  }

  // ---------- timer & sampling ----------
  function startTimer(){
    if (state.started) return;
    state.started = true;
    state.startTimeMs = performance.now();
    state.lastSampleSec = 0;
    state.samples = []; state.sampleSeconds = [];
    state.lastTypeAt = performance.now();
    state.afkSeconds = 0;
    state.timerId = setInterval(() => {
      state.remaining = Math.max(0, state.remaining - 0.1);
      els.time.textContent = state.remaining.toFixed(1);

      const now = performance.now();
      if (now - state.lastTypeAt > 2000) state.afkSeconds = Math.min(timerSeconds, state.afkSeconds + 0.1);

      const elapsedSec = Math.floor((now - state.startTimeMs)/1000);
      if (elapsedSec > state.lastSampleSec){
        state.lastSampleSec = elapsedSec;
        const {wpm} = recomputeStats();
        state.samples.push(wpm);
        state.sampleSeconds.push(elapsedSec);
      }
      if (state.remaining <= 0) finish();
    }, 100);
  }

  function finish(){
    clearInterval(state.timerId); state.timerId = null;
    showResultsPage();
  }

  // ---------- input / control ----------
  function reset(newText=true){
    clearInterval(state.timerId); state.timerId = null;
    state.started = false; state.index = 0; state.viewRow = 0;
    state.remaining = timerSeconds;
    els.time.textContent = state.remaining.toFixed(1);

    if (newText || !state.text) state.text = pickText(wordsTarget);
    state.text = normalizeText(state.text);
    state.chars = state.text.split('');
    buildLayout();
    state.marks = new Array(state.chars.length).fill(0);

    recomputeStats();
    focusSink();
    ensureCaretVisible();
    hideResultsPage();
  }

  function handleKeydown(e){
    const key = (e.key || ""), withMod = e.ctrlKey || e.metaKey || e.altKey;
    if (!els.overlay.classList.contains('show') && resultsView.classList.contains('show') === false) focusSink();

    if (key.toLowerCase() === 'r' && withMod){ e.preventDefault(); reset(false); return; }
    if (key.toLowerCase() === 'n' && withMod){ e.preventDefault(); reset(true);  return; }
    if (key === 'Escape'){
      if (els.overlay.classList.contains('show')) { hideOverlay(); return; }
      if (resultsView.classList.contains('show')) { hideResultsPage(); reset(false); return; }
      e.preventDefault(); reset(false); return;
    }
  }

  function handleInput(e){
    if (els.overlay.classList.contains('show') || resultsView.classList.contains('show')) return;

    const it = e.inputType || "", data = e.data;
    if (!state.started && (it === "insertText" || it === "insertCompositionText")) startTimer();

    if (it === "deleteContentBackward"){
      if (state.index > 0){
        state.index--; state.marks[state.index] = 0;
        ensureCaretVisible(); recomputeStats();
      }
      return;
    }

    if (it === "insertText" || it === "insertCompositionText"){
      if (state.index >= state.chars.length){ finish(); return; }
      const str = data ?? "";
      for (const c of str){
        const expected = state.chars[state.index];
        state.marks[state.index] = (c === expected) ? 1 : -1;
        state.index++; state.lastTypeAt = performance.now();
        ensureCaretVisible();
        if (state.index >= state.chars.length) break;
      }
      recomputeStats();
      if (state.index >= state.chars.length) finish();
      return;
    }

    if (it === "insertFromPaste" && e.data){
      for (const c of e.data){
        if (state.index >= state.chars.length) break;
        const expected = state.chars[state.index];
        state.marks[state.index] = (c === expected) ? 1 : -1;
        state.index++; state.lastTypeAt = performance.now();
      }
      ensureCaretVisible(); recomputeStats();
      if (state.index >= state.chars.length) finish();
    }
  }

  // ---------- custom text ----------
  function showOverlay(){ els.overlay.classList.add('show'); els.customArea.value = state.text; setTimeout(()=>els.customArea.focus(),0); }
  function hideOverlay(){ els.overlay.classList.remove('show'); focusSink(); }
  function useCustomText(){
    const txt = normalizeText(els.customArea.value);
    if (!txt){ hideOverlay(); return; }
    state.text = txt; reset(false); hideOverlay();
  }

  // ---------- RESULTS PAGE ----------
  function showResultsPage(){
    const {correct, wrong, typed, wpm, raw, acc} = recomputeStats();
    const missed = Math.max(0, state.chars.length - typed);

    // consistency from WPM samples
    let cons = "‚Äî";
    if (state.samples.length >= 2){
      const avg = state.samples.reduce((a,b)=>a+b,0)/state.samples.length;
      const sd = Math.sqrt(state.samples.map(v=>Math.pow(v-avg,2)).reduce((a,b)=>a+b,0)/(state.samples.length-1));
      const cv = avg>0 ? (sd/avg)*100 : 100;
      cons = `${Math.max(0, Math.min(100, Math.round(100 - cv))) }%`;
    }

    const afkPct = Math.round((state.afkSeconds / timerSeconds) * 100);

    els.resWpm.textContent = Math.round(wpm);
    els.resAcc.textContent = `${acc}%`;
    els.resType.textContent = `time ${timerSeconds} ‚Ä¢ english`;
    els.resRaw.textContent = Math.round(raw);
    els.resChars.textContent = `${correct}/${wrong}/0/${missed}`;
    els.resCons.textContent = cons;
    els.resTime.textContent = `${timerSeconds}s`;
    els.resOther.textContent = afkPct>0 ? `afk detected (${afkPct}%)` : "‚Äî";

    drawResultChart();

    // swap to results view
    for (const el of typingEls) el.style.display = 'none';
    resultsView.classList.add('show');
  }

  function hideResultsPage(){
    resultsView.classList.remove('show');
    for (const el of typingEls) el.style.display = '';
  }

  function drawResultChart(){
    const c = els.resChart, g = c.getContext('2d');
    const W = c.width, H = c.height;
    g.clearRect(0,0,W,H);
    g.fillStyle = "#0d1623"; g.fillRect(0,0,W,H);
    // grid
    g.strokeStyle = "#223148"; g.lineWidth = 1;
    g.beginPath(); for (let x=40; x<W; x+=60){ g.moveTo(x,20); g.lineTo(x,H-30); } g.stroke();
    g.beginPath(); for (let y=20; y<H-30; y+=30){ g.moveTo(40,y); g.lineTo(W-10,y); } g.stroke();

    const xs = state.sampleSeconds, ys = state.samples;
    if (!xs.length) return;
    const maxWpm = Math.max(40, Math.max(...ys) * 1.2);
    const x0 = 40, y0 = H-30, x1 = W-10, y1 = 20;
    const xscale = (x1 - x0) / Math.max(1, xs[xs.length-1]);
    const yscale = (y0 - y1) / maxWpm;

    g.strokeStyle = "#e2b714"; g.lineWidth = 2;
    g.beginPath();
    for (let i=0;i<xs.length;i++){
      const x = x0 + xs[i]*xscale;
      const y = y0 - ys[i]*yscale;
      if (i===0) g.moveTo(x,y); else g.lineTo(x,y);
    }
    g.stroke();
  }

  // ---------- focus ----------
  function focusSink(){
    try { els.sink.focus({preventScroll:true}); } catch {}
    try { els.sink.setSelectionRange(els.sink.value.length, els.sink.value.length); } catch {}
  }
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible'
        && !els.overlay.classList.contains('show')
        && !resultsView.classList.contains('show')) {
      focusSink();
    }
  });
  window.addEventListener('focus', () => {
    if (!els.overlay.classList.contains('show') && !resultsView.classList.contains('show')) focusSink();
  });
  canvas.addEventListener('pointerdown', () => {
    if (!els.overlay.classList.contains('show') && !resultsView.classList.contains('show')) focusSink();
  });
  app.addEventListener('pointerdown', () => {
    if (!els.overlay.classList.contains('show') && !resultsView.classList.contains('show')) focusSink();
  });

  // ---------- wire ----------
  function syncURL(){
    const url = new URL(location.href);
    url.searchParams.set('w', wordsTarget);
    url.searchParams.set('t', timerSeconds);
    history.replaceState({}, '', url);
  }

  els.restart.addEventListener('click', () => reset(false));     // repeat
  els.newText.addEventListener('click', () => reset(true));       // next
  els.shorter.addEventListener('click', () => { wordsTarget = clamp(wordsTarget-5, 5, 200); els.wordCount.textContent = wordsTarget; reset(true); syncURL(); });
  els.longer.addEventListener('click', () => { wordsTarget = clamp(wordsTarget+5, 5, 200); els.wordCount.textContent = wordsTarget; reset(true); syncURL(); });

  els.custom.addEventListener('click', showOverlay);
  els.cancelCustom.addEventListener('click', hideOverlay);
  els.useCustom.addEventListener('click', useCustomText);

  els.btnRepeat.addEventListener('click', () => { hideResultsPage(); reset(false); });
  els.btnNext.addEventListener('click',   () => { hideResultsPage(); reset(true);  });
  els.btnOwn.addEventListener('click',    () => { hideResultsPage(); showOverlay(); });

  document.addEventListener('keydown', handleKeydown);
  els.sink.addEventListener('input', handleInput);
  window.addEventListener('resize', () => { measure(); buildLayout(); ensureCaretVisible(); });

  // ---------- init ----------
  els.wordCount.textContent = WORD_GOAL_DEFAULT;
  els.timerBadge.textContent = `${timerSeconds}s`;

  measure();
  state.text = pickText(wordsTarget);
  reset(false);
  els.time.textContent = timerSeconds.toFixed(1);
  focusSink();

  requestAnimationFrame(render);
})();
</script>
</body>
</html>
